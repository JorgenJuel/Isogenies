
p = 439
#p=431
#p = 31
field = GF(p**2) # Field of p^2 elements
w = field.gen()
sqrt = 180*w + 169
E = EllipticCurve(field, [1,0])

Pr.<x,y,z> = ProjectiveSpace(field, 2)
# Frobenius
pi = Pr.hom([x^p, y^p, z^p], Pr)
# Iota
iota = Pr.hom([-x, sqrt * y, z], Pr)

pts = E.rational_points()

isogeny_ker_gen = E((125, 82, 1))
isogeny_degree = 5

kernel_set = [isogeny_ker_gen, 2* isogeny_ker_gen, 3* isogeny_ker_gen, 4*isogeny_ker_gen, 5*isogeny_ker_gen]

## Initialize quaterion algebra ramified at p and infty
Q.<i,j,k> = QuaternionAlgebra(QQ, -1, -p)
b1 = Q.basis()[0] # Trick to get 1 in Quaternion algebra 
b2 = i # Equivalent of iota
b3 = (1 + k)/2 # Equivalent of iota * pi
b4 = (i + j)/2 # Equivalent of iota + pi
#O0 = Q.ideal([b1, b2, b3, b4])
O0 = Q.maximal_order() # Default maximal order corresponds to this value
def point_divide(P, n):
	for Q in pts:
		if n * Q == P:
			return Q

## First generator: 1
def g1(P):
	return P

## Second generator: i
def g2(P):
	return E(iota(P))

## Third generator: (1 + i*pi)/2
def g3(P):
	S = P + E( (iota*pi)(P) )
	return point_divide(S, 2)

## Fourth generator: (i + pi)/2
def g4(P):
	S = E(iota(P)) + E(pi(P))
	return point_divide(S, 2)


def testIfCorrectGens(arr):
	gens_kernel_set = []
	for Q in pts:
		inKernel = True
		for f in arr:
			if f(Q) != 0:
				inKernel = False
		if inKernel:
			if Q not in kernel_set:
				print("Found point in intersection not in kernel_set")
				print(Q)
				return False
			gens_kernel_set.append(Q)

	is_correct = True
	for Q in kernel_set:
		if Q not in gens_kernel_set:
			print("Missing kernel point ", Q)
			is_correct = False
	
	return is_correct

def aNorm(a,b,c,d):
	nrm = a * a + a * c + c* c / 4 + b*b + b * d+ d*d /4 + p * d * d / 4 + p * c * c / 4
	if gcd(isogeny_degree, nrm) == isogeny_degree:
		return True
	return False

def actualNorm(a,b,c,d):
	nrm = a * a + a * c + c* c / 4 + b*b + b * d+ d*d /4 + p * d * d / 4 + p * c * c / 4
	nrm = nrm
	return nrm

def normCombination(a,b,c,d):
	return (a * b1 + b *b2 + c*b3 + d*b4).reduced_norm() 

## Performing norm calculation on O_1 generator elements modulo 5
def bNorm(a,b,c,d):
	nrm = a * a % isogeny_degree
	nrm = (nrm + a * c ) % isogeny_degree
	nrm = (nrm + c * c * 4) % isogeny_degree
	nrm = (nrm +  b*b) % isogeny_degree
	nrm = (nrm + b * d) % isogeny_degree
	nrm = (nrm + d * d * 4) % isogeny_degree
	nrm = (nrm + p * d * d * 4) % isogeny_degree
	nrm = (nrm + p * c * c* 4) % isogeny_degree
	return nrm == 0

def alphaComputer(a,b,c,d, gen1, gen2, gen3, gen4):
	return a * gen1 + b * gen2 + c*gen3 + d*gen4

def simpleIsogenyToIdeal(kernel_point):
	gen1 = g1(kernel_point)
	gen2 = g2(kernel_point)
	gen3 = g3(kernel_point)
	gen4 = g4(kernel_point)
	print("Generators: ", gen1, gen2, gen3, gen4)
	while True:
		a = randint(1,p)
		b = randint(1,p)
		c = randint(1,p)
		d = randint(1,p)
		if( normCombination(a,b,c,d) % 5 == 0 ):
			if( alphaComputer(a,b,c,d, gen1, gen2, gen3, gen4) == 0):
				print("Found a match", a,b,c,d)
				print("Successfully computed element. It has norm", normCombination(a,b,c,d))
				return (a,b,c,d)

def computeForwardIdeal(isogeny_ker_gen, basis):
	while True:
		print("Step #1, find alpha, such that I = O*n + O*alpha")
		(a,b,c,d) = simpleIsogenyToIdeal(isogeny_ker_gen)
		alpha = a * basis[0] + b * basis[1] + c * basis[2] + d*basis[3]
		print(alpha)
		print("Step #2, find basis of I")
		# I = O * n + O * alpha
		try:
			ideal_On = [b1 * isogeny_degree, b2 * isogeny_degree, b3 * isogeny_degree, b4 * isogeny_degree]
			ideal_Oalpha = [b1 * alpha, b2 * alpha, b3 * alpha, b4 * alpha]
			ideal_generators = []
			for w1 in ideal_On:
				for w2 in ideal_Oalpha:
					ideal_generators.append(w1 + w2)
			ideal = Q.ideal(ideal_generators, O0)
			print(ideal)
			print("Norm", ideal.norm())
			return ideal
		except:
			print("Found non-functional ideal, must try again")

print("Starting algorithm of computing the endomorphism ring of target curve")
print("We start with E_0: y^2 = x^3 + x over a field of characteristic ",p, "and endomorphism ring")
print(O0)
print("The isogeny is generated by kernel element ", isogeny_ker_gen, " and is of degree ", isogeny_degree)
computeForwardIdeal(isogeny_ker_gen, O0.basis())

print("Step #3, find End(E)")
print(ideal.right_order())
print(ideal.left_order())


#load("endomorphism_computations.sage")